# Ejercicio 3 ‚Äî Programaci√≥n basada en prototipos

## üß± Abstracci√≥n
En este trabajo represent√© el concepto de **Tarea** usando una **interfaz** y una **funci√≥n constructora**.
La interfaz me sirvi√≥ como molde de tipos porque en TypeScript es necesario definir qu√© tipo de dato tiene cada atributo.
Cada vez que se da un alta, se llama a la funci√≥n constructora y se crea un nuevo objeto con los datos que ingresa el usuario.

Inclu√≠ todos los atributos que ped√≠a el ejercicio, como t√≠tulo, descripci√≥n, estado, fechas y dificultad, ya que son los que definen bien una tarea.
No dej√© afuera nada que se solicitara en el enunciado.

---

## ‚öôÔ∏è Creaci√≥n e instanciaci√≥n protot√≠pica
A diferencia de las clases, trabaj√© con una **funci√≥n constructora**, que cumple un rol parecido pero de forma m√°s libre.
Cada vez que se utiliza `new`, se crea un nuevo objeto que tiene su propio contenido y un enlace interno al prototipo de la funci√≥n.

La diferencia con las clases es que con una funci√≥n constructora puedo crear los objetos desde cualquier parte del programa y no solo desde una clase principal.
Esto hace que el c√≥digo sea m√°s **flexible y din√°mico**, aunque tambi√©n **menos seguro**, porque cualquiera puede modificar los objetos.

Us√© este m√©todo porque el ejercicio ped√≠a hacerlo con el paradigma basado en prototipos, y adem√°s me result√≥ m√°s simple y directo para crear los objetos con sus propiedades.

---

## üîÅ Reutilizaci√≥n mediante prototipos
En este programa **no utilic√© reutilizaci√≥n mediante prototipo**, porque **no defin√≠ m√©todos dentro del prototipo**.
Cada acci√≥n del sistema (como alta, edici√≥n o b√∫squeda) est√° separada en su propio m√≥dulo.
Esto permite mantener las funciones bien organizadas y facilita el trabajo sin necesidad de compartir m√©todos entre objetos.

Si hubiera agregado funciones dentro del prototipo, todos los objetos creados podr√≠an usarlas, pero en este caso **no era necesario**, ya que el ejercicio solo ped√≠a manejar tareas individuales.

---

## üß© Encapsulamiento y modularidad
Aunque JavaScript no tiene un sistema real de encapsulamiento con atributos privados, s√≠ se puede lograr una forma de **encapsulamiento modular** usando `import` y `export`.
Por eso, divid√≠ el c√≥digo en diferentes archivos: alta, editar, buscar, mostrar y men√∫.
Cada uno cumple una funci√≥n espec√≠fica y solo expone lo que necesita compartir con el resto.

De esta manera, el programa queda m√°s **ordenado, legible y f√°cil de mantener**, porque cada m√≥dulo se encarga de una sola parte del funcionamiento general.

---

## üí¨ Conclusi√≥n
En este ejercicio apliqu√© los conceptos m√°s importantes del paradigma basado en prototipos:

- **Abstracci√≥n:** defin√≠ la estructura de una tarea mediante una interfaz.
- **Creaci√≥n protot√≠pica:** gener√© objetos nuevos a partir de una funci√≥n constructora.
- **Encapsulamiento modular:** separ√© el c√≥digo en varios archivos para mejorar la organizaci√≥n.

No apliqu√© **herencia, polimorfismo ni reutilizaci√≥n de m√©todos por prototipo**, ya que el programa no los requer√≠a.
El objetivo principal fue crear, editar y administrar tareas individuales de manera ordenada y flexible.
